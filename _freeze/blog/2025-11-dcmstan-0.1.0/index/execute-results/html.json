{
  "hash": "e4ac93bdb732965724a65a5f56fb7fce",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"dcmstan 0.1.0\"\ndate: 2025-11-26\nsubtitle: \"\"\ndescription: \"Initial release dcmstan for specifying diagnostic models and generating *Stan* code.\"\nimage: \"featured.jpg\"\nimage-alt: \"Person taking a test\"\ntitle-block-banner: featured.jpg\ntwitter-card:\n  image: \"featured.jpg\"\nopen-graph:\n  image: \"featured.jpg\"\nengine: knitr\ndoi: 10.59350/1kz71-zdj91\ncitation: true\n# one of: \"deep-dive\", \"learn\", \"package\", or \"other\" + relevant packages\ncategories:\n  - package\n  - dcmstan\n---\n\nWe are very pleased to announce the release of a new package, [dcmstan](https://dcmstan.r-dcm.org).\nThe goal of dcmstan is to provide users with a friendly interface for creating [*Stan*](https://mc-stan.org) scripts necessary for estimating diagnostic classification models (DCMs; also called cognitive diagnostic models [CDMs]).\ndcmstan is primarily intended to serve as a backend for `{measr}`, which will interface with `{rstan}` or `{cmdstanr}` to actually estimate a DCM.\nHowever, dcmstan can also be used independently if you want finer control of the estimation process or would like to customize the *Stan* script used for estimation.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](dcmstan.png){fig-align='center' width=60%}\n:::\n:::\n\n\nYou can install dcmstan from CRAN with:\n\n```r\ninstall.packages(\"dcmstan\")\n```\n\nThis blog post will highlight the major features and describe how dcmstan fits into the larger universe of r-dcm packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dcmstan)\n#> Warning: package 'dcmstan' was built under R version 4.5.2\n```\n:::\n\n\n## DCM specification\n\nFor this example, we'll create a specification for a DCM that we want to fit to ECPE data, which is available in the `{dcmdata}` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dcmdata)\n\necpe_qmatrix\n#> # A tibble: 28 × 4\n#>    item_id morphosyntactic cohesive lexical\n#>    <chr>             <int>    <int>   <int>\n#>  1 E1                    1        1       0\n#>  2 E2                    0        1       0\n#>  3 E3                    1        0       1\n#>  4 E4                    0        0       1\n#>  5 E5                    0        0       1\n#>  6 E6                    0        0       1\n#>  7 E7                    1        0       1\n#>  8 E8                    0        1       0\n#>  9 E9                    0        0       1\n#> 10 E10                   1        0       0\n#> # ℹ 18 more rows\n\necpe_data\n#> # A tibble: 2,922 × 29\n#>    resp_id    E1    E2    E3    E4    E5    E6    E7    E8    E9   E10   E11\n#>      <int> <int> <int> <int> <int> <int> <int> <int> <int> <int> <int> <int>\n#>  1       1     1     1     1     0     1     1     1     1     1     1     1\n#>  2       2     1     1     1     1     1     1     1     1     1     1     1\n#>  3       3     1     1     1     1     1     1     0     1     1     1     1\n#>  4       4     1     1     1     1     1     1     1     1     1     1     1\n#>  5       5     1     1     1     1     1     1     1     1     1     1     1\n#>  6       6     1     1     1     1     1     1     1     1     1     1     1\n#>  7       7     1     1     1     1     1     1     1     1     1     1     1\n#>  8       8     0     1     1     1     1     1     0     1     1     1     0\n#>  9       9     1     1     1     1     1     1     1     1     1     1     1\n#> 10      10     1     1     1     1     0     0     1     1     1     1     1\n#> # ℹ 2,912 more rows\n#> # ℹ 17 more variables: E12 <int>, E13 <int>, E14 <int>, E15 <int>, E16 <int>,\n#> #   E17 <int>, E18 <int>, E19 <int>, E20 <int>, E21 <int>, E22 <int>,\n#> #   E23 <int>, E24 <int>, E25 <int>, E26 <int>, E27 <int>, E28 <int>\n```\n:::\n\n\nWe can create a DCM specification using `dcm_specify()`.\nWe must provide our Q-matrix and, if present, the name of the Q-matrix column that contains the item identifiers.\nWe then must choose a measurement and structural model to be used.\nBy default, `dcm_specify()` will fit a loglinear cognitive diagnostic model [LCDM\\; @lcdm; @lcdm-handbook] with an unconstrained structural model.\nThese are the measurement models used by @ecpe in their examination of the ECPE data, so we will echo those choices here.\nHowever, there are many other measurement and structural models we could choose from.\nFor details on the specification options, see `vignette(\"dcmstan\", package = \"dcmstan\")`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\necpe_spec <- dcm_specify(\n  qmatrix = ecpe_qmatrix,\n  identifier = \"item_id\",\n  measurement_model = lcdm(),\n  structural_model = unconstrained()\n)\n\necpe_spec\n#> A loglinear cognitive diagnostic model (LCDM) measuring 3 attributes with 28\n#> items.\n#> \n#> ℹ Attributes:\n#> • \"morphosyntactic\" (13 items)\n#> • \"cohesive\" (6 items)\n#> • \"lexical\" (18 items)\n#> \n#> ℹ Attribute structure:\n#>   Unconstrained\n#> \n#> ℹ Prior distributions:\n#>   intercept ~ normal(0, 2)\n#>   maineffect ~ lognormal(0, 1)\n#>   interaction ~ normal(0, 2)\n#>   `Vc` ~ dirichlet(1, 1, 1)\n```\n:::\n\n\nWe can also specify prior distributions for the model.\nReasonable priors are defined by default, but custom priors can be specified for specific parameters or an entire type of parameters (e.g., applies to all intercept parameters).\nFor a list of possible parameters for given specification, see `get_parameters()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_parameters(ecpe_spec)\n#> # A tibble: 75 × 4\n#>    item_id type        attributes                coefficient\n#>    <chr>   <chr>       <chr>                     <chr>      \n#>  1 E1      intercept   <NA>                      l1_0       \n#>  2 E1      maineffect  morphosyntactic           l1_11      \n#>  3 E1      maineffect  cohesive                  l1_12      \n#>  4 E1      interaction morphosyntactic__cohesive l1_212     \n#>  5 E2      intercept   <NA>                      l2_0       \n#>  6 E2      maineffect  cohesive                  l2_12      \n#>  7 E3      intercept   <NA>                      l3_0       \n#>  8 E3      maineffect  morphosyntactic           l3_11      \n#>  9 E3      maineffect  lexical                   l3_13      \n#> 10 E3      interaction morphosyntactic__lexical  l3_213     \n#> # ℹ 65 more rows\n```\n:::\n\n\n## *Stan* code and data\n\nOnce we have our specification, we can create the *Stan* code for estimating the model with `stan_code()`.\nThis code can either be passed directly to the `model_code` argument of `rstan::stan()`, or written to a `.stan` file, which can then be passed to the `file` argument of `rstan::stan()` or the `stan_file` argument of `cmdstanr::cmdstan_model()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstan_code(ecpe_spec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` scroll-output\n#> data {\n#>   int<lower=1> I;                      // number of items\n#>   int<lower=1> R;                      // number of respondents\n#>   int<lower=1> N;                      // number of observations\n#>   int<lower=1> C;                      // number of classes\n#>   array[N] int<lower=1,upper=I> ii;    // item for observation n\n#>   array[N] int<lower=1,upper=R> rr;    // respondent for observation n\n#>   array[N] int<lower=0,upper=1> y;     // score for observation n\n#>   array[R] int<lower=1,upper=N> start; // starting row for respondent R\n#>   array[R] int<lower=1,upper=I> num;   // number items for respondent R\n#> }\n#> parameters {\n#>   simplex[C] Vc;\n#> \n#>   ////////////////////////////////// item intercepts\n#>   real l1_0;\n#>   real l2_0;\n#>   real l3_0;\n#>   real l4_0;\n#>   real l5_0;\n#>   real l6_0;\n#>   real l7_0;\n#>   real l8_0;\n#>   real l9_0;\n#>   real l10_0;\n#>   real l11_0;\n#>   real l12_0;\n#>   real l13_0;\n#>   real l14_0;\n#>   real l15_0;\n#>   real l16_0;\n#>   real l17_0;\n#>   real l18_0;\n#>   real l19_0;\n#>   real l20_0;\n#>   real l21_0;\n#>   real l22_0;\n#>   real l23_0;\n#>   real l24_0;\n#>   real l25_0;\n#>   real l26_0;\n#>   real l27_0;\n#>   real l28_0;\n#> \n#>   ////////////////////////////////// item main effects\n#>   real<lower=0> l1_11;\n#>   real<lower=0> l1_12;\n#>   real<lower=0> l2_12;\n#>   real<lower=0> l3_11;\n#>   real<lower=0> l3_13;\n#>   real<lower=0> l4_13;\n#>   real<lower=0> l5_13;\n#>   real<lower=0> l6_13;\n#>   real<lower=0> l7_11;\n#>   real<lower=0> l7_13;\n#>   real<lower=0> l8_12;\n#>   real<lower=0> l9_13;\n#>   real<lower=0> l10_11;\n#>   real<lower=0> l11_11;\n#>   real<lower=0> l11_13;\n#>   real<lower=0> l12_11;\n#>   real<lower=0> l12_13;\n#>   real<lower=0> l13_11;\n#>   real<lower=0> l14_11;\n#>   real<lower=0> l15_13;\n#>   real<lower=0> l16_11;\n#>   real<lower=0> l16_13;\n#>   real<lower=0> l17_12;\n#>   real<lower=0> l17_13;\n#>   real<lower=0> l18_13;\n#>   real<lower=0> l19_13;\n#>   real<lower=0> l20_11;\n#>   real<lower=0> l20_13;\n#>   real<lower=0> l21_11;\n#>   real<lower=0> l21_13;\n#>   real<lower=0> l22_13;\n#>   real<lower=0> l23_12;\n#>   real<lower=0> l24_12;\n#>   real<lower=0> l25_11;\n#>   real<lower=0> l26_13;\n#>   real<lower=0> l27_11;\n#>   real<lower=0> l28_13;\n#> \n#>   ////////////////////////////////// item interactions\n#>   real<lower=-1 * min([l1_11,l1_12])> l1_212;\n#>   real<lower=-1 * min([l3_11,l3_13])> l3_213;\n#>   real<lower=-1 * min([l7_11,l7_13])> l7_213;\n#>   real<lower=-1 * min([l11_11,l11_13])> l11_213;\n#>   real<lower=-1 * min([l12_11,l12_13])> l12_213;\n#>   real<lower=-1 * min([l16_11,l16_13])> l16_213;\n#>   real<lower=-1 * min([l17_12,l17_13])> l17_223;\n#>   real<lower=-1 * min([l20_11,l20_13])> l20_213;\n#>   real<lower=-1 * min([l21_11,l21_13])> l21_213;\n#> }\n#> transformed parameters {\n#>   vector[C] log_Vc = log(Vc);\n#>   matrix[I,C] pi;\n#> \n#>   ////////////////////////////////// probability of correct response\n#>   pi[1,1] = inv_logit(l1_0);\n#>   pi[1,2] = inv_logit(l1_0+l1_11);\n#>   pi[1,3] = inv_logit(l1_0+l1_12);\n#>   pi[1,4] = inv_logit(l1_0);\n#>   pi[1,5] = inv_logit(l1_0+l1_11+l1_12+l1_212);\n#>   pi[1,6] = inv_logit(l1_0+l1_11);\n#>   pi[1,7] = inv_logit(l1_0+l1_12);\n#>   pi[1,8] = inv_logit(l1_0+l1_11+l1_12+l1_212);\n#>   pi[2,1] = inv_logit(l2_0);\n#>   pi[2,2] = inv_logit(l2_0);\n#>   pi[2,3] = inv_logit(l2_0+l2_12);\n#>   pi[2,4] = inv_logit(l2_0);\n#>   pi[2,5] = inv_logit(l2_0+l2_12);\n#>   pi[2,6] = inv_logit(l2_0);\n#>   pi[2,7] = inv_logit(l2_0+l2_12);\n#>   pi[2,8] = inv_logit(l2_0+l2_12);\n#>   pi[3,1] = inv_logit(l3_0);\n#>   pi[3,2] = inv_logit(l3_0+l3_11);\n#>   pi[3,3] = inv_logit(l3_0);\n#>   pi[3,4] = inv_logit(l3_0+l3_13);\n#>   pi[3,5] = inv_logit(l3_0+l3_11);\n#>   pi[3,6] = inv_logit(l3_0+l3_11+l3_13+l3_213);\n#>   pi[3,7] = inv_logit(l3_0+l3_13);\n#>   pi[3,8] = inv_logit(l3_0+l3_11+l3_13+l3_213);\n#>   pi[4,1] = inv_logit(l4_0);\n#>   pi[4,2] = inv_logit(l4_0);\n#>   pi[4,3] = inv_logit(l4_0);\n#>   pi[4,4] = inv_logit(l4_0+l4_13);\n#>   pi[4,5] = inv_logit(l4_0);\n#>   pi[4,6] = inv_logit(l4_0+l4_13);\n#>   pi[4,7] = inv_logit(l4_0+l4_13);\n#>   pi[4,8] = inv_logit(l4_0+l4_13);\n#>   pi[5,1] = inv_logit(l5_0);\n#>   pi[5,2] = inv_logit(l5_0);\n#>   pi[5,3] = inv_logit(l5_0);\n#>   pi[5,4] = inv_logit(l5_0+l5_13);\n#>   pi[5,5] = inv_logit(l5_0);\n#>   pi[5,6] = inv_logit(l5_0+l5_13);\n#>   pi[5,7] = inv_logit(l5_0+l5_13);\n#>   pi[5,8] = inv_logit(l5_0+l5_13);\n#>   pi[6,1] = inv_logit(l6_0);\n#>   pi[6,2] = inv_logit(l6_0);\n#>   pi[6,3] = inv_logit(l6_0);\n#>   pi[6,4] = inv_logit(l6_0+l6_13);\n#>   pi[6,5] = inv_logit(l6_0);\n#>   pi[6,6] = inv_logit(l6_0+l6_13);\n#>   pi[6,7] = inv_logit(l6_0+l6_13);\n#>   pi[6,8] = inv_logit(l6_0+l6_13);\n#>   pi[7,1] = inv_logit(l7_0);\n#>   pi[7,2] = inv_logit(l7_0+l7_11);\n#>   pi[7,3] = inv_logit(l7_0);\n#>   pi[7,4] = inv_logit(l7_0+l7_13);\n#>   pi[7,5] = inv_logit(l7_0+l7_11);\n#>   pi[7,6] = inv_logit(l7_0+l7_11+l7_13+l7_213);\n#>   pi[7,7] = inv_logit(l7_0+l7_13);\n#>   pi[7,8] = inv_logit(l7_0+l7_11+l7_13+l7_213);\n#>   pi[8,1] = inv_logit(l8_0);\n#>   pi[8,2] = inv_logit(l8_0);\n#>   pi[8,3] = inv_logit(l8_0+l8_12);\n#>   pi[8,4] = inv_logit(l8_0);\n#>   pi[8,5] = inv_logit(l8_0+l8_12);\n#>   pi[8,6] = inv_logit(l8_0);\n#>   pi[8,7] = inv_logit(l8_0+l8_12);\n#>   pi[8,8] = inv_logit(l8_0+l8_12);\n#>   pi[9,1] = inv_logit(l9_0);\n#>   pi[9,2] = inv_logit(l9_0);\n#>   pi[9,3] = inv_logit(l9_0);\n#>   pi[9,4] = inv_logit(l9_0+l9_13);\n#>   pi[9,5] = inv_logit(l9_0);\n#>   pi[9,6] = inv_logit(l9_0+l9_13);\n#>   pi[9,7] = inv_logit(l9_0+l9_13);\n#>   pi[9,8] = inv_logit(l9_0+l9_13);\n#>   pi[10,1] = inv_logit(l10_0);\n#>   pi[10,2] = inv_logit(l10_0+l10_11);\n#>   pi[10,3] = inv_logit(l10_0);\n#>   pi[10,4] = inv_logit(l10_0);\n#>   pi[10,5] = inv_logit(l10_0+l10_11);\n#>   pi[10,6] = inv_logit(l10_0+l10_11);\n#>   pi[10,7] = inv_logit(l10_0);\n#>   pi[10,8] = inv_logit(l10_0+l10_11);\n#>   pi[11,1] = inv_logit(l11_0);\n#>   pi[11,2] = inv_logit(l11_0+l11_11);\n#>   pi[11,3] = inv_logit(l11_0);\n#>   pi[11,4] = inv_logit(l11_0+l11_13);\n#>   pi[11,5] = inv_logit(l11_0+l11_11);\n#>   pi[11,6] = inv_logit(l11_0+l11_11+l11_13+l11_213);\n#>   pi[11,7] = inv_logit(l11_0+l11_13);\n#>   pi[11,8] = inv_logit(l11_0+l11_11+l11_13+l11_213);\n#>   pi[12,1] = inv_logit(l12_0);\n#>   pi[12,2] = inv_logit(l12_0+l12_11);\n#>   pi[12,3] = inv_logit(l12_0);\n#>   pi[12,4] = inv_logit(l12_0+l12_13);\n#>   pi[12,5] = inv_logit(l12_0+l12_11);\n#>   pi[12,6] = inv_logit(l12_0+l12_11+l12_13+l12_213);\n#>   pi[12,7] = inv_logit(l12_0+l12_13);\n#>   pi[12,8] = inv_logit(l12_0+l12_11+l12_13+l12_213);\n#>   pi[13,1] = inv_logit(l13_0);\n#>   pi[13,2] = inv_logit(l13_0+l13_11);\n#>   pi[13,3] = inv_logit(l13_0);\n#>   pi[13,4] = inv_logit(l13_0);\n#>   pi[13,5] = inv_logit(l13_0+l13_11);\n#>   pi[13,6] = inv_logit(l13_0+l13_11);\n#>   pi[13,7] = inv_logit(l13_0);\n#>   pi[13,8] = inv_logit(l13_0+l13_11);\n#>   pi[14,1] = inv_logit(l14_0);\n#>   pi[14,2] = inv_logit(l14_0+l14_11);\n#>   pi[14,3] = inv_logit(l14_0);\n#>   pi[14,4] = inv_logit(l14_0);\n#>   pi[14,5] = inv_logit(l14_0+l14_11);\n#>   pi[14,6] = inv_logit(l14_0+l14_11);\n#>   pi[14,7] = inv_logit(l14_0);\n#>   pi[14,8] = inv_logit(l14_0+l14_11);\n#>   pi[15,1] = inv_logit(l15_0);\n#>   pi[15,2] = inv_logit(l15_0);\n#>   pi[15,3] = inv_logit(l15_0);\n#>   pi[15,4] = inv_logit(l15_0+l15_13);\n#>   pi[15,5] = inv_logit(l15_0);\n#>   pi[15,6] = inv_logit(l15_0+l15_13);\n#>   pi[15,7] = inv_logit(l15_0+l15_13);\n#>   pi[15,8] = inv_logit(l15_0+l15_13);\n#>   pi[16,1] = inv_logit(l16_0);\n#>   pi[16,2] = inv_logit(l16_0+l16_11);\n#>   pi[16,3] = inv_logit(l16_0);\n#>   pi[16,4] = inv_logit(l16_0+l16_13);\n#>   pi[16,5] = inv_logit(l16_0+l16_11);\n#>   pi[16,6] = inv_logit(l16_0+l16_11+l16_13+l16_213);\n#>   pi[16,7] = inv_logit(l16_0+l16_13);\n#>   pi[16,8] = inv_logit(l16_0+l16_11+l16_13+l16_213);\n#>   pi[17,1] = inv_logit(l17_0);\n#>   pi[17,2] = inv_logit(l17_0);\n#>   pi[17,3] = inv_logit(l17_0+l17_12);\n#>   pi[17,4] = inv_logit(l17_0+l17_13);\n#>   pi[17,5] = inv_logit(l17_0+l17_12);\n#>   pi[17,6] = inv_logit(l17_0+l17_13);\n#>   pi[17,7] = inv_logit(l17_0+l17_12+l17_13+l17_223);\n#>   pi[17,8] = inv_logit(l17_0+l17_12+l17_13+l17_223);\n#>   pi[18,1] = inv_logit(l18_0);\n#>   pi[18,2] = inv_logit(l18_0);\n#>   pi[18,3] = inv_logit(l18_0);\n#>   pi[18,4] = inv_logit(l18_0+l18_13);\n#>   pi[18,5] = inv_logit(l18_0);\n#>   pi[18,6] = inv_logit(l18_0+l18_13);\n#>   pi[18,7] = inv_logit(l18_0+l18_13);\n#>   pi[18,8] = inv_logit(l18_0+l18_13);\n#>   pi[19,1] = inv_logit(l19_0);\n#>   pi[19,2] = inv_logit(l19_0);\n#>   pi[19,3] = inv_logit(l19_0);\n#>   pi[19,4] = inv_logit(l19_0+l19_13);\n#>   pi[19,5] = inv_logit(l19_0);\n#>   pi[19,6] = inv_logit(l19_0+l19_13);\n#>   pi[19,7] = inv_logit(l19_0+l19_13);\n#>   pi[19,8] = inv_logit(l19_0+l19_13);\n#>   pi[20,1] = inv_logit(l20_0);\n#>   pi[20,2] = inv_logit(l20_0+l20_11);\n#>   pi[20,3] = inv_logit(l20_0);\n#>   pi[20,4] = inv_logit(l20_0+l20_13);\n#>   pi[20,5] = inv_logit(l20_0+l20_11);\n#>   pi[20,6] = inv_logit(l20_0+l20_11+l20_13+l20_213);\n#>   pi[20,7] = inv_logit(l20_0+l20_13);\n#>   pi[20,8] = inv_logit(l20_0+l20_11+l20_13+l20_213);\n#>   pi[21,1] = inv_logit(l21_0);\n#>   pi[21,2] = inv_logit(l21_0+l21_11);\n#>   pi[21,3] = inv_logit(l21_0);\n#>   pi[21,4] = inv_logit(l21_0+l21_13);\n#>   pi[21,5] = inv_logit(l21_0+l21_11);\n#>   pi[21,6] = inv_logit(l21_0+l21_11+l21_13+l21_213);\n#>   pi[21,7] = inv_logit(l21_0+l21_13);\n#>   pi[21,8] = inv_logit(l21_0+l21_11+l21_13+l21_213);\n#>   pi[22,1] = inv_logit(l22_0);\n#>   pi[22,2] = inv_logit(l22_0);\n#>   pi[22,3] = inv_logit(l22_0);\n#>   pi[22,4] = inv_logit(l22_0+l22_13);\n#>   pi[22,5] = inv_logit(l22_0);\n#>   pi[22,6] = inv_logit(l22_0+l22_13);\n#>   pi[22,7] = inv_logit(l22_0+l22_13);\n#>   pi[22,8] = inv_logit(l22_0+l22_13);\n#>   pi[23,1] = inv_logit(l23_0);\n#>   pi[23,2] = inv_logit(l23_0);\n#>   pi[23,3] = inv_logit(l23_0+l23_12);\n#>   pi[23,4] = inv_logit(l23_0);\n#>   pi[23,5] = inv_logit(l23_0+l23_12);\n#>   pi[23,6] = inv_logit(l23_0);\n#>   pi[23,7] = inv_logit(l23_0+l23_12);\n#>   pi[23,8] = inv_logit(l23_0+l23_12);\n#>   pi[24,1] = inv_logit(l24_0);\n#>   pi[24,2] = inv_logit(l24_0);\n#>   pi[24,3] = inv_logit(l24_0+l24_12);\n#>   pi[24,4] = inv_logit(l24_0);\n#>   pi[24,5] = inv_logit(l24_0+l24_12);\n#>   pi[24,6] = inv_logit(l24_0);\n#>   pi[24,7] = inv_logit(l24_0+l24_12);\n#>   pi[24,8] = inv_logit(l24_0+l24_12);\n#>   pi[25,1] = inv_logit(l25_0);\n#>   pi[25,2] = inv_logit(l25_0+l25_11);\n#>   pi[25,3] = inv_logit(l25_0);\n#>   pi[25,4] = inv_logit(l25_0);\n#>   pi[25,5] = inv_logit(l25_0+l25_11);\n#>   pi[25,6] = inv_logit(l25_0+l25_11);\n#>   pi[25,7] = inv_logit(l25_0);\n#>   pi[25,8] = inv_logit(l25_0+l25_11);\n#>   pi[26,1] = inv_logit(l26_0);\n#>   pi[26,2] = inv_logit(l26_0);\n#>   pi[26,3] = inv_logit(l26_0);\n#>   pi[26,4] = inv_logit(l26_0+l26_13);\n#>   pi[26,5] = inv_logit(l26_0);\n#>   pi[26,6] = inv_logit(l26_0+l26_13);\n#>   pi[26,7] = inv_logit(l26_0+l26_13);\n#>   pi[26,8] = inv_logit(l26_0+l26_13);\n#>   pi[27,1] = inv_logit(l27_0);\n#>   pi[27,2] = inv_logit(l27_0+l27_11);\n#>   pi[27,3] = inv_logit(l27_0);\n#>   pi[27,4] = inv_logit(l27_0);\n#>   pi[27,5] = inv_logit(l27_0+l27_11);\n#>   pi[27,6] = inv_logit(l27_0+l27_11);\n#>   pi[27,7] = inv_logit(l27_0);\n#>   pi[27,8] = inv_logit(l27_0+l27_11);\n#>   pi[28,1] = inv_logit(l28_0);\n#>   pi[28,2] = inv_logit(l28_0);\n#>   pi[28,3] = inv_logit(l28_0);\n#>   pi[28,4] = inv_logit(l28_0+l28_13);\n#>   pi[28,5] = inv_logit(l28_0);\n#>   pi[28,6] = inv_logit(l28_0+l28_13);\n#>   pi[28,7] = inv_logit(l28_0+l28_13);\n#>   pi[28,8] = inv_logit(l28_0+l28_13);\n#> }\n#> model {\n#>   ////////////////////////////////// priors\n#>   Vc ~ dirichlet(rep_vector(1, C));\n#>   l1_0 ~ normal(0, 2);\n#>   l1_11 ~ lognormal(0, 1);\n#>   l1_12 ~ lognormal(0, 1);\n#>   l1_212 ~ normal(0, 2);\n#>   l2_0 ~ normal(0, 2);\n#>   l2_12 ~ lognormal(0, 1);\n#>   l3_0 ~ normal(0, 2);\n#>   l3_11 ~ lognormal(0, 1);\n#>   l3_13 ~ lognormal(0, 1);\n#>   l3_213 ~ normal(0, 2);\n#>   l4_0 ~ normal(0, 2);\n#>   l4_13 ~ lognormal(0, 1);\n#>   l5_0 ~ normal(0, 2);\n#>   l5_13 ~ lognormal(0, 1);\n#>   l6_0 ~ normal(0, 2);\n#>   l6_13 ~ lognormal(0, 1);\n#>   l7_0 ~ normal(0, 2);\n#>   l7_11 ~ lognormal(0, 1);\n#>   l7_13 ~ lognormal(0, 1);\n#>   l7_213 ~ normal(0, 2);\n#>   l8_0 ~ normal(0, 2);\n#>   l8_12 ~ lognormal(0, 1);\n#>   l9_0 ~ normal(0, 2);\n#>   l9_13 ~ lognormal(0, 1);\n#>   l10_0 ~ normal(0, 2);\n#>   l10_11 ~ lognormal(0, 1);\n#>   l11_0 ~ normal(0, 2);\n#>   l11_11 ~ lognormal(0, 1);\n#>   l11_13 ~ lognormal(0, 1);\n#>   l11_213 ~ normal(0, 2);\n#>   l12_0 ~ normal(0, 2);\n#>   l12_11 ~ lognormal(0, 1);\n#>   l12_13 ~ lognormal(0, 1);\n#>   l12_213 ~ normal(0, 2);\n#>   l13_0 ~ normal(0, 2);\n#>   l13_11 ~ lognormal(0, 1);\n#>   l14_0 ~ normal(0, 2);\n#>   l14_11 ~ lognormal(0, 1);\n#>   l15_0 ~ normal(0, 2);\n#>   l15_13 ~ lognormal(0, 1);\n#>   l16_0 ~ normal(0, 2);\n#>   l16_11 ~ lognormal(0, 1);\n#>   l16_13 ~ lognormal(0, 1);\n#>   l16_213 ~ normal(0, 2);\n#>   l17_0 ~ normal(0, 2);\n#>   l17_12 ~ lognormal(0, 1);\n#>   l17_13 ~ lognormal(0, 1);\n#>   l17_223 ~ normal(0, 2);\n#>   l18_0 ~ normal(0, 2);\n#>   l18_13 ~ lognormal(0, 1);\n#>   l19_0 ~ normal(0, 2);\n#>   l19_13 ~ lognormal(0, 1);\n#>   l20_0 ~ normal(0, 2);\n#>   l20_11 ~ lognormal(0, 1);\n#>   l20_13 ~ lognormal(0, 1);\n#>   l20_213 ~ normal(0, 2);\n#>   l21_0 ~ normal(0, 2);\n#>   l21_11 ~ lognormal(0, 1);\n#>   l21_13 ~ lognormal(0, 1);\n#>   l21_213 ~ normal(0, 2);\n#>   l22_0 ~ normal(0, 2);\n#>   l22_13 ~ lognormal(0, 1);\n#>   l23_0 ~ normal(0, 2);\n#>   l23_12 ~ lognormal(0, 1);\n#>   l24_0 ~ normal(0, 2);\n#>   l24_12 ~ lognormal(0, 1);\n#>   l25_0 ~ normal(0, 2);\n#>   l25_11 ~ lognormal(0, 1);\n#>   l26_0 ~ normal(0, 2);\n#>   l26_13 ~ lognormal(0, 1);\n#>   l27_0 ~ normal(0, 2);\n#>   l27_11 ~ lognormal(0, 1);\n#>   l28_0 ~ normal(0, 2);\n#>   l28_13 ~ lognormal(0, 1);\n#> \n#>   ////////////////////////////////// likelihood\n#>   for (r in 1:R) {\n#>     row_vector[C] ps;\n#>     for (c in 1:C) {\n#>       array[num[r]] real log_items;\n#>       for (m in 1:num[r]) {\n#>         int i = ii[start[r] + m - 1];\n#>         log_items[m] = y[start[r] + m - 1] * log(pi[i,c]) +\n#>                        (1 - y[start[r] + m - 1]) * log(1 - pi[i,c]);\n#>       }\n#>       ps[c] = log_Vc[c] + sum(log_items);\n#>     }\n#>     target += log_sum_exp(ps);\n#>   }\n#> }\n```\n\n\n:::\n:::\n\n\nBoth rstan and cmdstanr also require a list of data objects that correspond to the `data` block of the *Stan* code.\nThis can be created with `stan_data()`.\nNote that if you edit the generated *Stan* code to customize the estimation and add to the `data` block, you will need to also add corresponding objects to the data list before estimation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- stan_data(ecpe_spec, data = ecpe_data, identifier = \"resp_id\")\n\nstr(dat)\n#> List of 9\n#>  $ I    : int 28\n#>  $ R    : int 2922\n#>  $ N    : int 81816\n#>  $ C    : int 8\n#>  $ ii   : num [1:81816] 1 2 3 4 5 6 7 8 9 10 ...\n#>  $ rr   : num [1:81816] 1 1 1 1 1 1 1 1 1 1 ...\n#>  $ y    : int [1:81816] 1 1 1 0 1 1 1 1 1 1 ...\n#>  $ start: int [1:2922] 1 29 57 85 113 141 169 197 225 253 ...\n#>  $ num  : int [1:2922] 28 28 28 28 28 28 28 28 28 28 ...\n```\n:::\n\n\n## dcmstan + measr\n\ndcmstan is primarily intended to be a backend to `{measr}`.\nMany dcmstan functions are reexported by measr so that if you are using measr to estimate your model, you should not need to directly load or interact with dcmstan.\nFor example, `dcm_specify()` is reexported by measr, so one can simply create a model specification and pass that directly to `measr::dcm_estimate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(measr)\n\necpe_spec <- dcm_specify(\n  qmatrix = ecpe_qmatrix,\n  identifier = \"item_id\",\n  measurement_model = lcdm(),\n  structural_model = unconstrained()\n)\n\nmodel <- dcm_estimate(\n  dcm_spec = ecpe_spec,\n  data = ecpe_data,\n  identifier = \"resp_id\"\n)\n```\n:::\n\n\n`measr::dcm_estimate()` calls `stan_code()` and `stan_data()` internally to create the necessary *Stan* script and data list and then estimates the model using your chosen backend (i.e., rstan or cmdstanr).\nThus, a direct interface with dcmstan should only be necessary if you want to modify the *Stan* code that is generated by default.\n\n## Acknowledgments {.appendix}\n\nThe research reported here was supported by the Institute of Education Sciences, U.S. Department of Education, through Grants [R305D210045](https://ies.ed.gov/funding/grantsearch/details.asp?ID=4546) and [R305D240032](https://ies.ed.gov/funding/grantsearch/details.asp?ID=6075) to the University of Kansas Center for Research, Inc., ATLAS. The opinions expressed are those of the authors and do not represent the views of the the Institute or the U.S. Department of Education.\n\nFeatured photo by <a href=\"https://unsplash.com/@andreas_haslinger?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Andreas Haslinger</a> on <a href=\"https://unsplash.com/photos/a-close-up-of-a-white-wall-with-a-black-frame-ywikyd-_DJs?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText\">Unsplash</a>.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}